<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8">
<title>RADAR WAR // Most már tényleg eltaláljuk őket</title>
<style>
    body {margin:0;background:#000;overflow:hidden;font-family:monospace;}
    canvas {display:block;}
    #hud {position:fixed;top:20px;right:20px;padding:15px 25px;background:rgba(0,20,0,0.92);color:#00ff88;font-size:22px;border:3px solid #00ff44;z-index:10;}
    #challenge {position:fixed;top:20px;left:20px;padding:18px 40px;background:rgba(0,30,0,0.95);color:#ffdd00;font-size:38px;font-weight:bold;border:5px solid #ffff00;z-index:10;white-space:nowrap;}
    #answer {position:fixed;top:110px;left:20px;width:360px;padding:16px;font-size:38px;text-align:center;background:#001100;color:#00ff00;border:5px solid #ffff00;outline:none;z-index:10;}
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="hud">
    Életek: <span id="lives">5</span><br>
    Elpusztítva: <span id="destroyed">0</span>
</div>

<div id="challenge"></div>
<input id="answer" type="number" placeholder="szorzat → Enter" autocomplete="off">

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let w = canvas.width = innerWidth, h = canvas.height = innerHeight, cx = w/2, cy = h/2;
window.addEventListener('resize',()=>{w=canvas.width=innerWidth;h=canvas.height=innerHeight;cx=w/2;cy=h/2;});

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const beep = (f=800,d=0.08,v=0.25)=>{let o=audioCtx.createOscillator();o.type='square';let g=audioCtx.createGain();o.frequency.value=f;o.connect(g);g.connect(audioCtx.destination);g.gain.setValueAtTime(v,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+d);o.start();o.stop(audioCtx.currentTime+d);};

let lives = 5, destroyed = 0, activeChallenge = null, rockets = [], t = 0;
let difficulty = 1;
setInterval(()=>{difficulty = Math.min(10, difficulty + 0.5);}, 25000);

const enemies = Array.from({length: 4},()=>({
    angle: Math.random()*Math.PI*2,
    speed: 0.00018 + Math.random()*0.00015,
    drift: (Math.random()-0.5)*0.00004,
    dist: -Math.min(w,h)*0.7,
    challenged: false,
    locked: false
}));

const challengeDiv = document.getElementById('challenge');
const input = document.getElementById('answer');
const hudLives = document.getElementById('lives');
const hudDestroyed = document.getElementById('destroyed');
const updateHUD = ()=>{hudLives.textContent=lives;hudDestroyed.textContent=destroyed;};

input.addEventListener('keydown', e=>{
    if(e.key==='Enter' && activeChallenge){
        if(parseInt(input.value) === activeChallenge.correct){
            // RAKÉTA INDÍTÁSA A CÉLPONT AKTUÁLIS POZÍCIÓJA FELÉ (nem csak szög!)
            const target = enemies[activeChallenge.i];
            rockets.push({
                targetIndex: activeChallenge.i,
                progress: 0
            });
            target.locked = true;
            beep(1600,0.12,0.4);
        }else beep(180,0.4,0.35);
        activeChallenge=null; challengeDiv.style.display='none'; input.value='';
    }
});

function draw(){
    ctx.fillStyle='rgba(0,0,0,0.095)'; ctx.fillRect(0,0,w,h);

    ctx.strokeStyle='#001a00'; ctx.lineWidth=1;
    for(let i=1;i<8;i++){ctx.beginPath();ctx.arc(cx,cy,i*Math.min(w,h)/15,0,Math.PI*2);ctx.stroke();}

    const sweep = (t*0.037)%(Math.PI*2);
    const R = Math.min(w,h)/2.15;

    // zöld sugár
    const lg=ctx.createLinearGradient(cx,cy,cx+Math.cos(sweep)*R,cy+Math.sin(sweep)*R);
    lg.addColorStop(0,'#00ff00');lg.addColorStop(0.94,'#00ff88');lg.addColorStop(1,'#88ffcc');
    ctx.strokeStyle=lg; ctx.lineWidth=2.4; ctx.shadowBlur=16; ctx.shadowColor='#00ff66';
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(sweep)*R,cy+Math.sin(sweep)*R); ctx.stroke();
    ctx.shadowBlur=0;

    // köd
    const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,R);
    grad.addColorStop(0,'rgba(50,255,100,0.52)'); grad.addColorStop(0.04,'rgba(0,255,50,0.19)');
    grad.addColorStop(0.22,'rgba(0,80,0,0.03)'); grad.addColorStop(1,'transparent');
    ctx.fillStyle=grad; ctx.globalAlpha=0.74;
    ctx.beginPath(); ctx.arc(cx,cy,R,sweep-0.13,sweep+0.13); ctx.lineTo(cx,cy); ctx.fill();
    ctx.globalAlpha=1;

    // ELLENSÉGEK + friss pozíció számítás
    for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        e.dist += e.speed*110; e.angle += e.drift;
        if(e.dist > R*1.2){
            if(e.challenged && !e.locked) lives--;
            enemies.splice(i,1);
            enemies.push({angle:Math.random()*Math.PI*2,speed:0.00018+Math.random()*0.00015+difficulty*0.00003,drift:(Math.random()-0.5)*0.00004,dist:-Math.min(w,h)*0.7,challenged:false,locked:false});
            continue;
        }

        const ex = cx + Math.cos(e.angle)*e.dist;
        const ey = cy + Math.sin(e.angle)*e.dist;
        const a = Math.atan2(ey-cy,ex-cx);
        const diff = ((sweep-a+Math.PI*3)%(Math.PI*2))-Math.PI;
        const hit = Math.abs(diff)<0.11;

        if(hit && !e.challenged && !activeChallenge){
            const maxR = 8 + difficulty*3;
            const maxTheta = 6 + difficulty*4;
            const r = Math.round(Math.random()*(maxR-4)+4);
            const theta = Math.round(Math.random()*(maxTheta-4)+4);
            activeChallenge={i,r,theta,correct:r*theta};
            e.challenged=true;
            challengeDiv.textContent=`${r} × ${theta} = ?`;
            challengeDiv.style.display='block';
            input.focus(); beep(1000,0.15,0.35);
        }

        ctx.fillStyle=`rgba(100,255,180,${Math.abs(diff)<0.18?1:0.18})`;
        ctx.beginPath(); ctx.arc(ex,ey,5.5,0,Math.PI*2); ctx.fill();

        if(hit){
            ctx.shadowBlur=30; ctx.shadowColor='#00ff00'; ctx.fillStyle='#00ff99';
            ctx.beginPath(); ctx.arc(ex,ey,11,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
            ctx.globalAlpha=0.7; ctx.strokeStyle='#00ff88'; ctx.lineWidth=3;
            ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex-Math.cos(e.angle)*35,ey-Math.sin(e.angle)*35); ctx.stroke();
            ctx.globalAlpha=1;
        }
    }

    // RAKÉTÁK – most már pontosan a célpont aktuális pozíciójára repülnek
    for(let i=rockets.length-1;i>=0;i--){
        const r = rockets[i];
        r.progress += 0.045;

        const target = enemies[r.targetIndex];
        if(!target || target.dist > R*1.2){ rockets.splice(i,1); continue; }

        const tx = cx + Math.cos(target.angle)*target.dist;
        const ty = cy + Math.sin(target.angle)*target.dist;

        const rx = cx + (tx - cx) * r.progress;
        const ry = cy + (ty - cy) * r.progress;

        ctx.strokeStyle='#ffff00'; ctx.lineWidth=5; ctx.shadowBlur=38; ctx.shadowColor='#ffff00';
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(rx,ry); ctx.stroke();
        ctx.shadowBlur=0;

        // TALÁLAT + robbanás effekt
        if(r.progress >= 0.98){
            destroyed++;
            beep(280,0.5,0.6);

            // robbanás
            ctx.shadowBlur=80; ctx.shadowColor='#ff8800';
            ctx.fillStyle='#ffff88';
            ctx.beginPath(); ctx.arc(tx,ty,30,0,Math.PI*2); ctx.fill();
            ctx.shadowBlur=0;

            // célpont törlése
            enemies.splice(r.targetIndex,1);
            enemies.push({angle:Math.random()*Math.PI*2,speed:0.00018+Math.random()*0.00015+difficulty*0.00003,drift:(Math.random()-0.5)*0.00004,dist:-Math.min(w,h)*0.7,challenged:false,locked:false});

            rockets.splice(i,1);
        }
    }

    if(lives<=0){
        lives=5; destroyed=0; rockets=[]; activeChallenge=null;
        challengeDiv.style.display='none'; input.value='';
        enemies.length=0; for(let i=0;i<4;i++) enemies.push({angle:Math.random()*Math.PI*2,speed:0.00018+Math.random()*0.00015,drift:(Math.random()-0.5)*0.00004,dist:-Math.min(w,h)*0.7,challenged:false,locked:false});
        difficulty=1;
    }

    updateHUD(); t++; requestAnimationFrame(draw);
}
draw(); updateHUD();
</script>
</body>
</html>